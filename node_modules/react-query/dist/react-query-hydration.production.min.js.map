{"version":3,"file":"react-query-hydration.production.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../src/hydration/hydration.ts","../src/hydration/react.tsx"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import type { QueryClient } from '../core/queryClient'\nimport type { Query, QueryState } from '../core/query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from '../core/types'\nimport type { Mutation, MutationState } from '../core/mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nfunction defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nfunction defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options?: DehydrateOptions\n): DehydratedState {\n  options = options || {}\n\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options?.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach(mutation => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options?.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach(query => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach(dehydratedMutation => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state\n    )\n  })\n\n  queries.forEach(dehydratedQuery => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQuery.state\n    )\n  })\n}\n","import React from 'react'\n\nimport { useQueryClient } from 'react-query'\nimport { hydrate, HydrateOptions } from './hydration'\n\nexport function useHydrate(state: unknown, options?: HydrateOptions) {\n  const queryClient = useQueryClient()\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n}\n\nexport const Hydrate: React.FC<HydrateProps> = ({\n  children,\n  options,\n  state,\n}) => {\n  useHydrate(state, options)\n  return children as React.ReactElement<any>\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","defaultShouldDehydrateMutation","mutation","state","isPaused","defaultShouldDehydrateQuery","query","status","hydrate","client","dehydratedState","options","mutationCache","getMutationCache","queryCache","getQueryCache","mutations","queries","forEach","dehydratedMutation","build","defaultOptions","_options$defaultOptio","mutationKey","dehydratedQuery","get","queryHash","dataUpdatedAt","setState","_options$defaultOptio2","queryKey","useHydrate","queryClient","useQueryClient","optionsRef","React","useRef","current","useMemo","children","dehydrateMutations","shouldDehydrateMutation","getAll","push","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery"],"mappings":"wSAAe,SAASA,WACtBA,EAAWC,OAAOC,QAAU,SAAUC,OAC/B,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,KACrCG,EAASF,UAAUD,OAElB,IAAII,KAAOD,EACVN,OAAOQ,UAAUC,eAAeC,KAAKJ,EAAQC,KAC/CL,EAAOK,GAAOD,EAAOC,WAKpBL,IAGOS,MAAMC,KAAMR,WCoD9B,SAASS,EAA+BC,UAC/BA,EAASC,MAAMC,SAGxB,SAASC,EAA4BC,SACL,YAAvBA,EAAMH,MAAMI,OA2Cd,SAASC,EACdC,EACAC,EACAC,MAE+B,iBAApBD,GAAoD,OAApBA,OAIrCE,EAAgBH,EAAOI,mBACvBC,EAAaL,EAAOM,gBAEpBC,EAAaN,EAAoCM,WAAa,GAC9DC,EAAWP,EAAoCO,SAAW,GAEhED,EAAUE,SAAQ,SAAAC,SAChBP,EAAcQ,MACZX,aAEKE,YAAAA,EAASU,uBAATC,EAAyBN,WAC5BO,YAAaJ,EAAmBI,cAElCJ,EAAmBhB,UAIvBc,EAAQC,SAAQ,SAAAM,SACRlB,EAAQQ,EAAWW,IAAID,EAAgBE,WAGzCpB,EACEA,EAAMH,MAAMwB,cAAgBH,EAAgBrB,MAAMwB,eACpDrB,EAAMsB,SAASJ,EAAgBrB,OAMnCW,EAAWM,MACTX,aAEKE,YAAAA,EAASU,uBAATQ,EAAyBZ,SAC5Ba,SAAUN,EAAgBM,SAC1BJ,UAAWF,EAAgBE,YAE7BF,EAAgBrB,WC3Jf,SAAS4B,EAAW5B,EAAgBQ,OACnCqB,EAAcC,mBAEdC,EAAaC,EAAMC,OAAOzB,GAChCuB,EAAWG,QAAU1B,EAMrBwB,EAAMG,SAAQ,WACRnC,GACFK,EAAQwB,EAAa7B,EAAO+B,EAAWG,WAExC,CAACL,EAAa7B,iFAQ4B,gBAC7CoC,IAAAA,SACA5B,IAAAA,eAGAoB,IAFA5B,MAEkBQ,GACX4B,eD0CF,SACL9B,EACAE,WAIMK,EAAkC,GAClCC,EAA6B,OAEC,cALpCN,EAAUA,GAAW,aAKR6B,oBAA8B,KACnCC,EACJ9B,EAAQ8B,yBAA2BxC,EAErCQ,EACGI,mBACA6B,SACAxB,SAAQ,SAAAhB,GACHuC,EAAwBvC,IAC1Bc,EAAU2B,KA7CpB,SAA2BzC,SAClB,CACLqB,YAAarB,EAASS,QAAQY,YAC9BpB,MAAOD,EAASC,OA0CKyC,CAAkB1C,WAKP,cAA9BS,YAASkC,kBAA4B,KACjCC,EACJnC,EAAQmC,sBAAwBzC,EAElCI,EACGM,gBACA2B,SACAxB,SAAQ,SAAAZ,GACHwC,EAAqBxC,IACvBW,EAAQ0B,KAhDlB,SAAwBrC,SACf,CACLH,MAAOG,EAAMH,MACb2B,SAAUxB,EAAMwB,SAChBJ,UAAWpB,EAAMoB,WA4CEqB,CAAezC,aAK7B,CAAEU,UAAAA,EAAWC,QAAAA"}